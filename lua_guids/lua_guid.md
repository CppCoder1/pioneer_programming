# Язык программирования Lua

Lua — язык с динамической типизацией. В нем нет определений
типов; каждое значение содержит в себе свой собственный тип.

## Типы в Lua

В Lua существует шесть базовых типов: ```nil```, ```boolean```, ```number```, ```string```,
```table```, ```function```. Функция ```type``` возвращает имя типа
любого заданного значения:

```lua
print(type("Hello world")) --> string
print(type(10.4*3)) --> number
print(type(print)) --> function
print(type(type)) --> function
print(type(true)) --> boolean
print(type(nil)) --> nil
print(type(type(X))) --> string
```

Последняя строка вернет ```string``` вне зависимости от значения X,
поскольку результат ```type``` всегда является строкой.
У переменных нет предопределенных типов; любая переменная
может содержать значения любого типа:

```lua
print(type(a)) --> nil ('a' не инициализирована)
a = 10
print(type(a)) --> number
a = "a string!!"
print(type(a)) --> string
a = print -- да, это допустимо!
a(type(a)) --> function
```

```nil``` — это тип, имеющий единственное значение ```nil```. Он необходим для того, чтобы изобразить отсутствие какого-либо значения (то же самое, что и ```NULL``` в C++).

Тип ```boolean``` обладает двумя значениями — ```true``` и ```false```, которые
представляют традиционные логические (или булевы) значения. Однако,
не только булевы значения могут выражать условие: в Lua условие
может быть представлено любым значением. Проверки условий
(например, условий в управляющих структурах) считают ```nil``` и булево
```false``` ложными, а все прочие значения истинными. В частности, при
проверках условий Lua считает ноль и пустую строку истинными
значениями.

Тип ```number``` представляет вещественные числа, т.е. числа двойной
точности с плавающей точкой (тип ```double``` в C++). В Lua нет
целочисленного типа (тип ```int``` в C++).

Тип ```string``` в Lua имеет обычный смысл: последовательность
символов. Lua поддерживает все 8-битовые символы, и его строки
могут содержать символы с любыми числовыми кодами, включая нуль-
символы. Это значит, что вы можете хранить в виде строк любые
бинарные данные. Вы также можете хранить строки Юникода в любом
представлении (UTF-8, UTF-16 и т. д.).

В отличие от C++, в Lua для изменений строки надо создавать новую, а не изменять имеющуюся, и в эту новую строку необходимо присвоить изменённую строку.

```lua
a = "one string"
b = string.gsub(a, "one", "another") -- меняет части строки
print(a) --> строка "one"
print(b) --> строка "another"
```

## Приведение типов
Lua обеспечивает автоматическое преобразование между числами и
строками во время выполнения программ. Любая числовая операция,
примененная к строке, пытается преобразовать эту строку в число:

```lua
print("10" + 1) --> 11
print("10 + 1") --> 10 + 1
print("-5.3e-10"*"2") --> -1.06e-09
print("hello" + 1) -- ОШИБКА (невозможно преобразовать "hello")
```

Верно и обратное — каждый раз, когда Lua находит число там, где
ожидает строку, он преобразует это число в строку:

```lua 
print(10 .. 20) --> 1020
```

(Операция ```..``` служит в Lua для конкатенации строк. Когда вы
записываете ее сразу после числа, вы должны отделить их друг от друга
при помощи пробела; иначе Lua решит, что первая точка — это
десятичная точка числа.)

Если вам нужно явно преобразовать строку в число, то вы можете
воспользоваться функцией tonumber, которая возвращает nil, если строка
не является правильным числом Lua:

```lua
line = io.read() -- читает строку
  n = tonumber(line) -- пытается преобразовать ее в число
  if n == nil then
    error(line .. " is not a valid number")
  else
  print(n*2)
end
```

Для преобразования числа в строку вы можете использовать
функцию tostring или конкатенировать число с пустой строкой:

```lua
print(tostring(10) == "10") --> true
print(10 .. "" == "10") --> true
```

## Таблицы (```table```)
Тип table представляет ассоциативные массивы. Ассоциативный
массив — это массив, который может быть индексирован не только
числами, но и строками или любым другим значением языка, кроме ```nil```.

Таблицы являются главным (на самом деле единственным)
механизмом структурирования данных в Lua, притом очень
эффективным. Мы используем таблицы для представления обычных
массивов, множеств, записей и других структур данных простым,
однородным и эффективным способом. Также Lua использует таблицы
для представления пакетов и объектов. Когда мы пишем ```io.read```, мы
думаем о «функции ```read``` из модуля ```io```». Для Lua это выражение означает
«индексировать таблицу ```io```, используя строку ```read``` в качестве ключа».

Таблицы в Lua не являются ни значениями, ни переменными; они
объекты. Вы можете рассматривать таблицу как
динамически выделяемый объект; ваша программа работает только со
ссылками (указателями) на них. Lua никогда не прибегает к скрытому
копированию или созданию новых таблиц. Более того, вам не нужно
объявлять таблицу в Lua; на самом деле для этого даже не существует
способа. Вы создаете таблицы при помощи выражения-конструктора,
которое в своей простейшей форме записывается как ```{}```:
```lua
a = {} -- создает таблицу и сохраняет ссылку на нее в 'a'

k = "x"
a[k] = 10 -- новая запись с ключом "x" и значением 10
a[20] = "great" -- новая запись с ключом 20 и значением "great"
print(a["x"]) --> 10

k = 20
print(a[k]) --> "great"

a["x"] = a["x"] + 1 -- инкрементирует запись "x"
print(a["x"]) --> 11
```

Таблица всегда анонимна. Не существует постоянной связи между
переменной, которая хранит таблицу, и самой таблицей:

```lua
a = {}
a["x"] = 10
b = a -- 'b' ссылается на ту же таблицу, что и 'a'
print(b["x"]) --> 10

b["x"] = 20
print(a["x"]) --> 20

a = nil -- лишь 'b' по-прежнему ссылается на ту таблицу
b = nil -- ссылок на таблицу не осталось
```

Каждая таблица может хранить значения с разными типами индексов
и растет по мере добавления новых записей:

```lua
a = {} -- пустая таблица
-- создает 1000 новых записей

for i = 1, 1000 do
  a[i] = i*2
end

print(a[9]) --> 18

a["x"] = 10
print(a["x"]) --> 10
print(a["y"]) --> nil
```

Обратите внимание на последнюю строку: как и глобальные
переменные, поля таблицы возвращают ```nil```, когда не инициализированы.
Так же, как и с глобальными переменными, вы можете присвоить полю
таблицы ```nil```, чтобы его удалить. Это не совпадение: Lua хранит
глобальные переменные в обыкновенных таблицах.

Для представления записей вы используете имя поля как индекс. Lua
поддерживает это представление, предлагая ```a.name``` в качестве
синтаксического сахара для ```a["name"]```. Таким образом, мы можем
переписать последние строки предыдущего примера следующим, более
чистым образом:

```lua
a.x = 10 -- то же, что и a["x"] = 10

print(a.x) -- то же, что и print(a["x"])
print(a.y) -- то же, что и print(a["y"])
```

Для Lua эти две формы эквивалентны и могут свободно использоваться
вместе.

Типичная ошибка новичков — спутать ```а.х``` с ```а[х]```. Первая форма
соответствует ```а["х"]```, то есть таблица индексирована при помощи
строки ```"х"```. Вторая форма означает, что таблица индексирована при
помощи значения переменной х. Взгляните на разницу:

```lua
a = {}
x = "y"
a[x] = 10 -- записывает 10 в поле "y"

print(a[x]) --> 10 -- значение поля "y"
print(a.x) --> nil -- значение поля "x" (не определено)
print(a.y) --> 10 -- значение поля "y"
```

Чтобы представить традиционный массив или список, просто
используйте таблицу с целочисленными индексами. Нет ни способа, ни
необходимости объявлять размер; вы всего лишь инициализируете те
элементы, которые вам нужны:

```lua
-- считывает 10 строк, сохраняя их в таблице
a = {}
for i = 1, 10 do
a[i] = io.read()
end
```

Для того, чтобы узнать длину таблицы, необходимо применить унарный оператор ```#```, который вовращает длину таблицы. Поскольку в самой таблице можно обратиться 
к любому полю (элементу таблицы) и получить значение (если данный элемент не инициализирован, то он вернёт значение ```nil```), то длиной таблицы является 
"расстояние" между первым и последним инициализированными полями.

```lua
-- печатает строки
for i = 1, #a do
  print(a[i])
end
```

Когда вы не уверены насчет действительных типов ваших
индексов, для верности используйте явное приведение типов:

```lua
i = 10; j = "10"; k = "+10"
a = {}
a[i] = "one value"
a[j] = "another value"
a[k] = "yet another value"

print(a[i]) --> one value
print(a[j]) --> another value
print(a[k]) --> yet another value

print(a[tonumber(j)]) --> one value
print(a[tonumber(k)]) --> one value
```

В вашей программе могут появиться трудноуловимые ошибки, если не
уделять внимание данному моменту.

## Функции (```function```)

Функции (тип function) являются в Lua значениями первого класса:
программы могут хранить функции в переменных, передавать функции
как аргументы для других функций и возвращать функции как
результаты.

```lua
a = print

a("Hello world!") --Выведет Hello world!
```

# Операции и выражения
## Арифметические операции

Lua поддерживает стандартные арифметические операции: бинарные
```+``` (сложение), ```-``` (вычитание), ```*``` (умножение), ```/``` (деление), ```^```
(возведение в степень), ```%``` (остаток от деления) и унарную ```-```
(отрицание). Все они работают с вещественными числами. Например,
```х^0.5``` вычисляет квадратный корень из х, а ```х^(-1/3)``` вычисляет обратно
пропорциональное значение его кубического корня.

## Операции сравнения
Lua предоставляет следующие операции сравнения: </br>
```<``` ```>``` ```<=``` ```>=``` ```==``` ```~=```</br>

Все эти операции всегда производят булево значение.
Операция ```==``` проверяет на равенство; операция ```~=``` проверяет на
неравенство. Мы можем применять обе эти операции к любым двум
значениям. Если значения обладают разными типами, то Lua считает, что
они не равны. В противном случае Lua сравнивает их в соответствии с
их типами. В частности, ```nil``` равно только самому себе.
Lua сравнивает таблицы и пользовательские данные по ссылке, то
есть два таких значения считаются равными, только если они являются
одним и тем же объектом. Например, после выполнения следующего
кода:

```lua
a = {}; a.x = 1; a.y = 0
b = {}; b.x = 1; b.y = 0
c = a
```

мы получим ```а == с```, но ```а ~= b```.

## Логические операции

Логические операции — это ```and```, ```or``` и ```not```. Как и управляющие
структуры, все логические операции трактуют ```false``` и ```nil``` как ложные, а
все остальные — как истинные значения. Операция ```and``` возвращает свой
первый аргумент, если он ложный, иначе она возвращает свой второй
аргумент. Операция ```or``` возвращает свой первый аргумент, если он не
ложный; иначе она возвращает свой второй аргумент:

```lua
print(4 and 5) --> 5
print(nil and 13) --> nil
print(false and 13) --> false
print(4 or 5) --> 4
print(false or 5) --> 5
```

Обе операции, and и or, используют сокращенное вычисление, то
есть они вычисляют свой второй операнд только при необходимости.
Сокращенное вычисление обеспечивает отсутствие ошибок во время
выполнения для выражений вроде ```(type(v) == "table" and v.tag ==
"h1")```: Lua не будет пытаться вычислить ```v.tag```, когда ```v``` не является
таблицей.

Операция ```not``` всегда возвращает булево значение:

```lua
print(not nil) --> true
print(not false) --> true
print(not 0) --> false
print(not not 1) --> true
print(not not nil) --> false
```

## Конкатенация

Lua обозначает операцию конкатенации строк как ```..``` (две точки).
Если один из операндов является числом, то Lua переведет его в строку.
(Некоторые языки используют для конкатенации операцию ```+```, но в Lua
```3+5``` отличается от ```3..5```.)
```lua
print("Hello " .. "World") --> Hello World
print(0 .. 1) --> 01
print(000 .. 01) --> 01
```
Помните, что строки в Lua являются неизменяемыми значениями.
Операция конкатенации всегда создает новую строку, не изменяя свои
операнды:

```lua
a = "Hello"
print(a .. " World") --> Hello World
print(a) --> Hello
```

## Операция длины
Операция длины работает со строками и таблицами. Со строками она
дает количество байт в строке. С таблицами она возвращает длину
представленной ими последовательности.
С операцией длины связано несколько распространенных идиом для
работы с последовательностями:

```lua
print(a[#a]) -- печатает последнее значение последовательности a

a[#a] = nil -- удаляет это последнее значение
a[#a + 1] = v -- добавляет 'v' к концу списка
```

## Приоритеты операций

Приоритеты операций в Lua, от высшего к низшему, следуют этой
таблице:
```^```</br>
```not```  ```#```  ```-``` (унарный)</br>
```*```    ```.```  ```%```</br>
```+```    ```-```  </br>
```..```</br>
```<``` ```>``` ```<=``` ```>=``` ```~=``` ```==```</br>
```and```</br>
```or```</br>

Все бинарные операции левоассоциативны, за исключением ```^```
(возведение в степень) и ```..``` (конкатенация), которые
правоассоциативны. Поэтому следующие выражения слева
эквивалентны выражениям справа:

```a+i < b/2+1``` <--> ```(a+i) < ((b/2)+1)```</br>
```5+x^2*8``` <--> ```5+((x^2)*8)```</br>
```a < y and y <= z``` <--> ```(a < y) and (y <= z)```</br>
```-x^2``` <--> ```-(x^2)```</br>
```x^y^z``` <--> ```x^(y^z)```</br>

Когда сомневаетесь, всегда используйте круглые скобки.

## Конструкторы таблиц

Конструкторы — это выражения, которые создают и
инициализируют таблицы. Они являются отличительной чертой Lua и
одним из его наиболее полезных и универсальных механизмов.

Простейший конструктор — это пустой конструктор, ```{}```, который
создает пустую таблицу; мы уже видели его раньше. Конструкторы
также инициализируют списки. Например, оператор

```lua
days = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday",
"Friday", "Saturday"}
```

проинициализирует ```days[1]``` строкой ```"Sunday"``` (первый элемент
конструктора имеет индекс 1, а не 0), ```days[2]``` строкой ```"Monday"``` и т. д.:

```lua
print(days[4]) --> Wednesday
```

Lua также предлагает специальный синтаксис для инициализации
таблиц, похожий на записи, как в следующем примере;

```lua
a = {x=10, y=20}
Эта строка эквивалентна следующим командам:
a = {}; a.x=10; a.y=20
```

Исходное выражение, тем не менее, проще и быстрее, поскольку Lua
сразу создает таблицу с правильным размером.
Вне зависимости от того, каким конструктором мы пользовались для
создания таблицы, из нее всегда можно добавлять и удалять поля:

```lua
w = {x=0, y=0, label="console"}
x = {math.sin(0), math.sin(1), math.sin(2)}

w[1] = "another field" -- добавляет ключ 1 в таблицу 'w'
x.f = w -- добавляет ключ "f" в таблицу 'x'

print(w["x"]) --> 0
print(w[1]) --> another field
print(x.f[1]) --> another field

w.x = nil -- удаляет поле "x"
```

Однако, как я только что заметил, создание таблицы при помощи
правильного конструктора более эффективно и, кроме того, более
наглядно.
Мы можем смешивать эти два стиля инициализации (записи и списки)
в одном и том же конструкторе:

```lua
polyline = {color="blue",
  thickness=2,
  npoints=4,
  {x=0, y=0}, -- polyline[1]
  {x=-10, y=0}, -- polyline[2]
  {x=-10, y=1}, -- polyline[3]
  {x=0, y=1} -- polyline[4]
}
```

Приведенный выше пример также показывает, как можно вкладывать
конструкторы один в другой для представления более сложных
структур данных. Каждый из элементов ```polyline[i]``` — это таблица,
представляющая собой запись:

```lua
print(polyline[2].x) --> -10
print(polyline[4].y) --> 1
```

У этих двух форм конструктора есть свои ограничения. Например, вы
не можете инициализировать поля отрицательными индексами или
строковыми индексами, которые не являются правильными
идентификаторами. Для таких целей есть другой, более общий формат. В
этом формате мы явно пишем индекс, который должен быть
инициализирован как выражение, между квадратными скобками:

```lua
opnames = {["+"] = "add", ["-"] = "sub",
["*"] = "mul", ["/"] = "div"}
i = 20; s = "-"
a = {[i+0] = s, [i+1] = s..s, [i+2] = s..s..s}
print(opnames[s]) --> sub
print(a[22]) --> ---
```

Этот синтаксис хоть и более громоздкий, но при этом более гибкий: обе
формы (в стиле списков и в стиле записей) являются частными случаями
этого более общего синтаксиса. Конструктор ```{x = 0, y = 0}```
эквивалентен ```{["x"] = 0, ["y"] = 0}```, а конструктор ```{"r", "g", "b"}```
эквивалентен ```{[1] = "r", [2] = "g", [3] = "b"}```.
Вы всегда можете поставить запятую после последней записи. Эти
замыкающие запятые необязательны, но всегда допустимы:
```a = {[1]="red", [2]="green", [3]="blue",}```

# Операторы

## Операторы присваивания

Присваивание — это базовое средство изменения значения
переменной или поля таблицы:

```lua
a = "hello" .. "world"
t.n = t.n + 1
```

Lua позволяет осуществлять множественное присваивание (multiple
assignment), которое присваивает список значений списку переменных за
один шаг. Например, в присваивании
```lua
a, b = 10, 2*x
```
переменная a получает значение 10, а переменная b — значение 2*x.
Во множественном присваивании Lua сперва вычисляет все значения
и только затем выполняет присваивания. Поэтому мы можем
использовать множественное присваивание, чтобы поменять местами
два значения, как в следующих примерах:

```lua
x, y = y, x -- меняет местами значения 'x' с 'y'
a[i], a[j] = a[j], a[i] -- меняет местами значения 'a[i]' с
'a[j]'
```

Lua всегда приводит количество значений к количеству переменных:
когда список значений короче списка переменных, дополнительные
переменные получают в качестве своих значений ```nil```; когда длиннее
список значений, дополнительные значения просто отбрасываются:

```lua
a, b, c = 0, 1
print(a, b, c) --> 0 1 nil

a, b = a+1, b+1, b+2 -- значение b+2 игнорируется
print(a, b) --> 1 2

a, b, c = 0
print(a, b, c) --> 0 nil nil
```
Последнее присваивание в примере выше показывает распространенную
ошибку. Для инициализации набора переменных вы должны
предоставить значение для каждой из них:
```lua
a, b, c = 0, 0, 0
print(a, b, c) --> 0 0 0
```

## Локальные переменные

Кроме глобальных, Lua поддерживает и локальные переменные. Мы
создаем локальные переменные при помощи оператора ```local```:

```lua
j = 10 -- глобальная переменная
local i = 1 -- локальная переменная
```

В отличие от глобальных переменных, область видимости локальной
переменной ограничена блоком, где она была объявлена. Блок — это
тело управляющей структуры, тело функции или кусок кода (файл или
строка, где переменная была объявлена):

```lua
x = 10
local i = 1 -- локальная для куска

while i <= x do
  local x = i*2 -- локальная для тела while
  print(x) --> 2, 4, 6, 8, ...
  i = i + 1
end

if i > 20 then
  local x -- локальная для тела "then"
  x = 20
  print(x + 2) -- (напечатает 22, если условие выполнится)
else
  print(x) --> 10 (глобальная переменная)
end

print(x) --> 10 (глобальная переменная)
```

Подобные блоки с do удобны и тогда, когда вам нужен более точный
контроль над областью видимости некоторых локальных переменных:

```lua
do
  local a2 = 2*a
  local d = (b^2 - 4*a*c)^(1/2)
  x1 = (-b + d)/a2
  x2 = (-b - d)/a2
end -- область видимости 'a2' и 'd' заканчивается здесь
print(x1, x2)
```

Хороший стиль программирования заключается в применении
локальных переменных везде, где это возможно. Локальные переменные
помогают вам избежать засорения глобального окружения ненужными
именами. Более того, доступ к локальной переменной быстрее, чем к
глобальной. И наконец, локальная переменная перестает существовать,
как только заканчивается ее область видимости, позволяя сборщику
мусора освободить память, занимаемую ее значением.

Lua обрабатывает объявления локальных переменных как операторы.
Таким образом, вы можете записывать локальные объявления везде, где
вы можете записать оператор. Область видимости объявленных
переменных начинается сразу после объявления и длится до конца блока.

Каждое объявление может включать инициализирующее присваивание,
которое действует так же, как и традиционное присваивание: лишние
значения отбрасываются, а лишние переменные получают значение ```nil```.

Если в объявлении нет инициализирующего присваивания, то оно
инициализирует все свои переменные значением ```nil```:

```lua
local a, b = 1, 10
if a < b then
print(a) --> 1
local a -- неявное '= nil'
print(a) --> nil
end -- завершает блок, начатый с 'then'
print(a, b) --> 1 10
```

В Lua распространена следующая идиома:
```lua
local foo = foo
```

Этот код создает локальную переменную ```foo``` и инициализирует ее
значением глобальной переменной ```foo```. (Локальная ```foo``` становится
видимой только после этого объявления.) Эта идиома удобна, когда
куску необходимо предварительно сохранить первоначальное значение
переменной, даже если позже какая-нибудь другая функция изменит
значение глобальной foo; это также ускоряет доступ к ```foo```.

Поскольку многие языки вынуждают вас объявлять все локальные
переменные в начале блока (или процедуры), некоторые считают, что
объявлять переменные в середине блока является плохой практикой. Все
как раз наоборот: объявляя переменную, только когда она
действительно нужна, вам редко понадобится объявлять ее без
инициализирующего значения (и поэтому вы вряд ли забудете ее
проинициализироватъ). Более того, вы уменьшаете область видимости
переменной, что облегчает чтение кода.

## Управляюшие конструкции

Lua предоставляет небольшой и традиционный набор управляющих
структур: ```if``` для условного выполнения, а ```while```, ```repeat``` и ```for``` для
итерации. Все управляющие структуры обладают явным завершающим
элементом: end завершает ```if```, ```for``` и ```while```, а ```until``` завершает ```repeat```.

Условное выражение управляющей структуры может дать любое
значение. Помните о том, что Lua считает все значения, отличные от
```false``` и ```nil```, истинными. (В частности, Lua считает истинными ноль и
пустую строку.)

### ```if``` ```then``` ```else```

Оператор ```if``` проверяет свое условие и в зависимости от результата
выполняет одну из своих частей, ```then``` или ```else```. Часть с ```else``` является
необязательной.

```lua
if a < 0 then a = 0 end
if a < b then return a else return b end
if line > MAXLINES then
  showpage()
  line = 0
end
```

Для записи вложенных операторов ```if``` вы можете использовать ```elseif```. Это
аналогично ```else```, за которым следует ```if```, но при этом не возникает
необходимости в нескольких ```end```:

```lua
if op == "+" then
  r = a + b
elseif op == "-" then
  r = a - b
elseif op == "*" then
  r = a*b
elseif op == "/" then
  r = a/b
else
  error("invalid operation")
end
```

Поскольку в Lua нет оператора ```switch```, такие конструкции довольно
распространены.

### ```while```

Как следует из названия, ```while``` повторяет свое тело до тех пор, пока
условие истинно. Как обычно, Lua сперва проверяет условие ```while```; если
оно ложно, то цикл завершается; в противном случае Lua выполняет
тело цикла и повторяет данный процесс.

```lua
local i = 1

while a[i] do
  print(a[i])
  i = i + 1
end
```
### ```repeat```

Как следует из названия, оператор ```repeat–until``` повторяет свое тело
до тех пор, пока условие не станет истинным. Данный оператор
производит проверку условия после выполнения тела, поэтому тело
цикла будет выполнено хотя бы один раз.

```lua
-- печатает первую непустую введенную строку
repeat
  line = io.read()
  until line ~= ""
print(line)
```

В отличие от многих других языков, в Lua условие входит в область
видимости локальной переменной, объявленной внутри цикла:

```lua
local sqr = x/2
repeat
sqr = (sqr + x/sqr)/2
local error = math.abs(sqr^2 - x)
until error < x/10000 -- local 'error' still visible here
```

### Числовой for
Оператор ```for``` существует в двух вариантах: числовой ```for``` и общий ```for```.
Числовой ```for``` имеет следующий синтаксис:

```lua
for var = exp1, exp2, exp3 do
<что-либо>
end
```

Этот цикл будет выполнять что-либо для каждого значения ```var``` от ```exp1```
до ```ехр2```, используя ```ехр3``` как шаг для увеличения ```var```. Это третье
выражение необязательно; когда оно отсутствует, Lua считает значение
шага равным 1. В качестве типичных примеров можно привести

```lua
for i = 1, f(x) do print(i) end
for i = 10, 1, -1 do print(i) end
```

Если вам нужен цикл без верхнего предела, то вы можете использовать
константу ```math.huge```:

```lua
for i = 1, math.huge do
  if (0.3*i^3 - 20*i^2 - 500 >= 0) then
    print(i)
    break
  end
end
```

У цикла for есть некоторые тонкости, которые вам желательно знать,
чтобы применять его наиболее эффективно. Во-первых, все три
выражения вычисляются только один раз, перед началом цикла. Скажем,
в нашем первом примере Lua вызовет ```f(х)``` всего один раз. Во-вторых,
управляющая переменная является локальной переменной,
автоматически объявляемой оператором ```for```, и она видна лишь внутри
цикла. Типичная ошибка — полагать, что эта переменная все еще
существует после окончания цикла:

```lua
for i = 1, 10 do print(i) end
max = i -- вероятно, неправильно! здесь 'i' глобальная
```

Если вам нужно значение управляющей переменной после цикла
(обычно когда вы прерываете цикл), то вы должны сохранить ее
значение в другой переменной:

```lua
-- находит значение в списке
local found = nil
for i = 1, #a do
  if a[i] < 0 then
    found = i -- сохраняет значение 'i'
    break
  end
end
print(found)
```
В-третьих, вы никогда не должны изменять значение управляющей
переменной: эффект подобных изменений не предсказуем. Если вы
хотите закончить цикл ```for``` до его нормального завершения, используйте
```break``` (как в предыдущем примере).

### Общий ```for```

Общий ```for``` обходит все значения, возвращаемые итерирующей
функцией:

```lua
-- печатает все значения таблицы 't'
for k, v in pairs(t) do print(k, v) end
```

Этот пример использует ```pairs```, удобную итерирующую функцию для
перебора таблицы, предоставляемую базовой библиотекой Lua. На
каждом шаге этого цикла ```k``` получает ключ, a ```v``` получает значение,
связанное с этим ключом.

Несмотря на свою кажущуюся простоту, общий ```for``` обладает
широкими возможностями. С подходящими итераторами вы можете в
легкочитаемой форме перебрать практически все, что угодно.

Стандартные библиотеки предоставляют несколько итераторов,
позволяющих нам перебирать строки файла (```io.lines```), пары таблицы
(```pairs```), элементы последовательности (```ipars```), слова внутри строки
(```string.gmatch```) и т.д.

У общего и числового циклов есть два одинаковых свойства:
переменные цикла локальны для тела цикла, и вы никогда не должны
присваивать им какие-либо значения.
Рассмотрим более конкретный пример применения общего ```for```.
Допустим, у вас есть таблица с названиями дней недели:
```lua
days = {"Sunday", "Monday", "Tuesday", "Wednesday",
"Thursday", "Friday", "Saturday"}
```

Теперь вы хотите перевести название дня в его номер по счету в неделе.

Вы можете искать заданное имя в таблице. Однако, как вы скоро узнаете,
в Lua поиск применяется редко. Более эффективным подходом является
построение обратной таблицы, скажем, ```revDays```, в которой названия дней
используются как индексы, а номера используются как значения. Эта
таблица выглядела бы следующим образом:

```lua
revDays = {["Sunday"] = 1, ["Monday"] = 2,
["Tuesday"] = 3, ["Wednesday"] = 4,
["Thursday"] = 5, ["Friday"] = 6,
["Saturday"] = 7}
```

Тогда все, что вам нужно, чтобы найти номер дня по названию, — это
обратиться по индексу этой обратной таблицы:

```lua
x = "Tuesday"
print(revDays[x]) --> 3
```

Разумеется, нам не требуется объявлять эту обратную таблицу вручную.
Мы можем автоматически построить ее из первоначальной:

```lua
revDays = {}
for k,v in pairs(days) do
  revDays[v] = k
end
```

Этот цикл выполнит присваивание для каждого элемента ```days```, где
переменная ```k``` получит ключ ```(1, 2, ...)```, a ```v``` получит значение ```("Sunday",
"Monday", ...)```.

### ```break```, ```return``` и ```goto```

Операторы ```break``` и ```return``` позволяют нам выпрыгнуть (осуществить
безусловный переход) из блока. Оператор goto позволяет нам прыгнуть
практически в любую точку функции.
Мы используем оператор ```break``` для завершения цикла. Этот оператор
прерывает внутренний цикл (```for```, ```repeat``` или ```while```), который его
содержит; он не может быть использован за пределами цикла. После
прерывания программа продолжит выполнение с точки, следующей
сразу после прерванного цикла.

Оператор ```return``` возвращает результаты из функции, если они есть,
или просто завершает ее. В конце каждой функции присутствует
неявный возврат из нее, поэтому вам необязательно его использовать,
если ваша функция завершается естественным образом, не возвращая
никакого значения.

Из синтаксических соображений оператор ```return``` может быть только
последним оператором блока: другими словами, либо последним
оператором в вашем куске, либо прямо перед ```end```, ```else``` или ```until```. В
следующем примере ```return``` — это последний оператор блока ```then```.

```lua
local i = 1
while a[i] do
  if a[i] == v then return i end
  i = i + 1
end
```

Обычно это именно те места, где мы используем ```return```, поскольку
любые другие операторы, следующие за ним, были бы недоступны.
Иногда, тем не менее, удобно писать ```return``` в середине блока; например,
вы можете отлаживать функцию и хотите избежать ее выполнения. В
подобных случаях вы можете использовать явный блок ```do``` вокруг
оператора ```return```:

```lua
function foo ()
return --<< СИНТАКСИЧЕСКАЯ ОШИБКА
-- 'return' является последним оператором в следующем куске
do return end -- OK
<другие операторы>
end
```

Оператор ```goto``` передает выполнение программы соответствующей
метке. Насчет ```goto``` были долгие обсуждения, и некоторые люди даже
сейчас считают, что эти операторы вредны для языков
программирования и должны быть из них исключены. Однако, ряд
существующих языков предлагает ```goto``` совершенно обоснованно.

Данные операторы являются мощным механизмом, который, будучи
использованным с осторожностью, способен лишь улучшить качество
вашего кода.

В Lua синтаксис для оператора goto вполне традиционный: это
зарезервированное слово ```goto```, за которым следует имя метки, которое
может быть любым допустимым идентификатором. Синтаксис для
метки немного более запутанный: два двоеточия, за которыми следует
имя метки, после которого идут еще два двоеточия, например, как
в ```::name::```. Эта сложность намеренная, чтобы заставить программиста
дважды подумать, прежде чем использовать ```goto```.

Lua накладывает некоторые ограничения на то, куда вы можете
прыгнуть при помощи ```goto```. Во-первых, метки следуют обычным
правилам видимости, поэтому вы не можете прыгнуть внутрь блока
(поскольку метка внутри блока невидима за его пределами). Во-вторых,
вы не можете выпрыгнуть из функции. (Обратите внимание, что первое
правило уже исключает возможность прыгнуть внутрь функции.) В-
третьих, вы не можете прыгнуть внутрь области видимости локальной
переменной.

Типичным и хорошо зарекомендовавшим себя применением ```goto```
является моделирование некоторой конструкции, которую вы узнали из
другого языка, но которая отсутствует в Lua, например ```continue```. 
Оператор ```continue``` — это просто
безусловный переход к метке в конце блока цикла;:

```lua
while some_condition do
  if some_other_condition then goto continue end
  <какой-нибудь код>
  ::continue::
end
```

### Функции

Функции являются основным механизмом абстракции операторов и
выражений в Lua. Функции могут выполнять определенное задание
(иногда называемое процедурой или подпрограммой в других языках) или
вычислять и возвращать значения. В первом случае мы используем вызов
функции как оператор; во втором случае мы используем его как
выражение:

```lua
print(8*9, 9/8)
a = math.sin(3) + math.cos(10)
print(os.date())
```

В обоих случаях заключение списка аргументов в круглые скобки
обозначает вызов; если у вызова функции нет аргументов, то мы все
равно должны написать пустой список () для обозначения вызова.
Существует особое исключение из этого правила: если у функции всего
один аргумент и этот аргумент либо строковый литерал, либо
конструктор таблицы, то круглые скобки необязательны:

```print "Hello World"``` <--> ```print("Hello World")```</br>
```dofile 'a.lua'``` <--> ```dofile ('a.lua')```</br>
```f{x=10, y=20}``` <--> ```f({x=10, y=20})```</br>
```type{}``` <--> ```type({})```</br>

Lua также предлагает специальный синтаксис для объектно-
ориентированных вызовов — операцию двоеточия. Выражение вроде
```о:foo(x)``` — это всего лишь другой способ написать ```o.foo(o,x)```, то есть
вызвать ```o.foo```, добавляя o в качестве первого дополнительного
аргумента.

Как мы видели в других примерах, определение функции следует
традиционному синтаксису, например, как показано ниже:

```lua
-- складывает элементы последовательности 'a'
function add (a)
  local sum = 0
  for i = 1, #a do
    sum = sum + a[i]
  end
  return sum
end
```

В этом синтаксисе определение функции содержит имя (в примере это
```add```), список параметров и тело, которое является списком операторов.
Параметры работают в точности как локальные переменные,
проинициализированные значениями аргументов, которые были
переданы вызову функции. Вы можете вызвать функцию с числом
аргументов, отличным от ее числа параметров. Lua приведет число
аргументов к числу параметров так же, как и при множественном
присваивании: лишние аргументы отбрасываются, лишние параметры
получают nil. Например, рассмотрим следующую функцию:

```lua
function f (a, b) print(a, b) end
```

Она обладает следующим поведением:

```lua
f(3) --> 3 nil
f(3, 4) --> 3 4
f(3, 4, 5) --> 3 4 (5 отбрасывается)
```

Хотя подобное поведение может привести к ошибкам
программирования (легко обнаруживаемым во время выполнения), оно
довольно удобно, особенно для аргументов по умолчанию. Например,
рассмотрим следующую функцию, инкрементирующую глобальный
счетчик:

```lua
function incCount (n)
n = n or 1
count = count + n
end
```

У этой функции 1 служит в качестве аргумента по умолчанию; т.е. вызов
```incCount()``` без аргументов увеличит count на единицу. Когда вы
вызываете ```incCount()```, Lua сперва инициализирует n значением ```nil```;
выражение с or возвращает свой второй операнд, и в результате Lua
присваивает переменной n стандартное значение 1.

## Множественные результаты

Нетрадиционной, но довольно удобной особенностью Lua является
то, что функции могут возвращать несколько значений. Так делают
некоторые предопределенные функции в Lua. Примером является
функция string.find, которая находит местоположение образца в строке.
Эта функция возвращает два индекса, когда находит образец: индекс
символа, с которого начинается образец, и индекс символа, на котором
он заканчивается. Множественное присваивание позволяет программе
получить оба результата:

```lua
s, e = string.find("hello Lua users", "Lua")
print(s, e) --> 7 9
```

(Обратите внимание, что индекс первого символа строки равен 1.)

Функции, которые мы пишем в Lua, также могут возвращать
множественные результаты при помощи перечисления их после
ключевого слова return. Например, функция для нахождения
максимального элемента в последовательности может возвращать и
максимальный элемент, и его местонахождение:

```lua
function maximum (a)
  local mi = 1 -- индекс максимального значения
  local m = a[mi] -- максимальное значение
  for i = 1, #a do
    if a[i] > m then
      mi = i; m = a[i]
    end
  end
  return m, mi
end

print(maximum({8,10,23,12,5})) --> 23 3
```

Lua всегда приводит количество результатов функции к
обстоятельствам ее вызова. Когда мы вызываем функцию как оператор,
Lua отбрасывает все результаты функции. Когда мы используем вызов
как выражение, Lua оставляет только первый результат. Мы получаем все
результаты лишь тогда, когда вызов является последним (или
единственным) выражением в списке выражений. В Lua эти списки
встречаются в четырех конструкциях: множественные присваивания,
аргументы в вызовах функций, конструкторы таблиц и операторы
return. Для иллюстрации всех этих случаев допустим, что у нас есть
такие определения для наших последующих примеров:

```lua
function foo0() end -- возвращает 0 значений
function foo1() return "a" end -- возвращает 1 значение
function foo2() return "a", "b" end -- возвращает 2 значения
```

При множественном присваивании вызов функции в качестве
последнего (или единственного) выражения произведет столько
результатов, сколько у нас переменных:

```lua
x,y = foo2() -- x="a", y="b"
x = foo2() -- x="a", "b" отбрасывается
x,y,z = 10,foo2() -- x=10, y="a", z="b"
```

Если функция не возвращает значения или возвращает их меньше, чем
нужно, то Lua произведет в качестве недостающих значений ```nil```:

```lua
x,y = foo0() -- x=nil, y=nil
x,y = foo1() -- x="a", y=nil
x,y,z = foo2() -- x="a", y="b", z=nil
```

Вызов функции, который не является последним элементом в списке,
всегда дает ровно один результат:
```lua
x,y = foo2(), 20 -- x="a", y=20
x,y = foo0(), 20, 30 -- x=nil, y=20, 30 отбрасывается
```

Когда вызов функции является последним (или единственным)
аргументом другого вызова, то все результаты первого вызова
передаются как аргументы для второго. Мы уже видели примеры этой
конструкции с функцией print. Поскольку функция print может получать
переменное число аргументов, оператор ```print(g())``` печатает все
результаты, возвращенные функцией ```g```.

```lua
print(foo0()) -->
print(foo1()) --> a
print(foo2()) --> a b
print(foo2(), 1) --> a 1
print(foo2() .. "x") --> ax (смотрите далее)
```

Когда вызов функции ```foo2``` происходит внутри выражения, Lua приводит
число результатов к одному; поэтому в последней строке конкатенация
использует только ```"а"```.

Если мы напишем ```f(g(х))```, где у ```f``` фиксированное число аргументов,
то Lua приведет число результатов ```g``` к числу параметров ```f```, как мы уже
видели ранее.

Конструктор таблицы тоже собирает все результаты вызова, без
каких-либо изменений:

```lua
t = {foo0()} -- t = {} (пустая таблица)
t = {foo1()} -- t = {"a"}
t = {foo2()} -- t = {"a", "b"}
```

Как обычно, это поведение встречается лишь тогда, когда вызов
является последним выражением в списке; вызовы в любых других
местах дают ровно один результат:
```lua
t = {foo0(), foo2(), 4} -- t[1] = nil, t[2] = "a", t[3] = 4
```

Наконец, оператор наподобие return ```f()``` возвращает все значения,
возвращаемые ```f```:

```lua
function foo (i)
  if i == 0 then return foo0()
  elseif i == 1 then return foo1()
  elseif i == 2 then return foo2()
  end
end

print(foo(1)) --> a
print(foo(2)) --> a b

print(foo(0)) -- (без результатов)
print(foo(3)) -- (без результатов)
```

Вы можете заставить вызов вернуть ровно один результат, заключив
его в дополнительную пару круглых скобок:

```lua
print((foo0())) --> nil
print((foo1())) --> a
print((foo2())) --> a
```

Будьте внимательны, так как оператор ```return``` не требует скобок вокруг
возвращаемого значения; любая пара круглых скобок, помещенная там,
считается дополнительной. Поэтому оператор вроде ```return(f(х))``` всегда
возвращает ровно одно значение, вне зависимости от того, сколько
значений возвращает функция ```f```. Иногда это именно то, что вам нужно,
иногда нет.

Специальной функцией, возвращающей несколько значений, является
```table.unpack```. Она получает массив и возвращает в качестве результатов
все элементы этого массива, начиная с индекса 1:

Вызов unpack возвращает все значения из а, которые становятся
аргументами вызова ```f```. Например, рассмотрим следующий вызов:
```lua
print(string.find("hello", "ll"))
```

Вы можете динамически построить эквивалентный вызов при помощи
следующего кода:

```lua
f = string.find
a = {"hello", "ll"}

print(f(table.unpack(a)))
print(table.unpack{10,20,30}) --> 10 20 30

a,b = table.unpack{10,20,30} -- a=10, b=20, 30 отбрасывается
```
# Замыкания

Когда мы определяем одну функцию внутри другой, она получает
полный доступ к локальным переменным окружающей ее функции; мы
называем это свойство лексической областью видимости (lexical scoping).

Хотя это правило видимости может показаться очевидным, на самом
деле это не так. Лексическая область видимости вместе с функциями
первого класса является высокоэффективной концепцией в языках
программирования, но многие языки ее не поддерживают.

Давайте начнем с простого примера. Пусть у вас есть список имен
студентов и таблица, которая ассоциирует имена с оценками; вам
требуется отсортировать список имен по их оценкам, начиная с более
высоких. Вы можете добиться этого следующим образом:
```lua
names = {"Peter", "Paul", "Mary"}
grades = {Mary = 10, Paul = 7, Peter = 8}
table.sort(names, function (n1, n2)
  return grades[n1] > grades[n2] -- сравнивает оценки
  end)
```
Теперь допустим, что вам нужно создать функцию для решения данной
задачи:
```lua
function sortbygrade (names, grades)
  table.sort(names, function (n1, n2)
    return grades[n1] > grades[n2] -- сравнивает оценки
    end)
end
```
Интересным моментом в этом примере является то, что анонимная
функция, переданная функции ```sort```, обращается к параметру ```grades```,
который является локальным для окружающей его функции ```sortbygrade```.

Внутри этой анонимной функции ```grades``` не является ни глобальной
переменной, ни локальной переменной, а является тем, что мы называем
нелокальной переменной. (По историческим причинам нелокальные
переменные в Lua также называются верхними значениями (upvalue).)

Почему данный момент так интересен? Потому что функции
являются значениями первого класса, и вследствие этого они могут
выйти из начальной области видимости своих переменных. Рассмотрим
следующий пример:

```lua
function newCounter ()
  local i = 0
  return function () -- анонимная функция
    i = i + 1
    return i
  end
end

c1 = newCounter()
print(c1()) --> 1
print(c1()) --> 2
```

В этом коде анонимная функция ссылается на нелокальную
переменную ```i``` для хранения своего счетчика. Однако, к тому времени,
как мы вызовем анонимную функцию, переменная ```i``` уже выйдет из своей
области видимости, поскольку функция, которая создала эту
переменную (```newCounter```), уже будет возвращена. Тем не менее, Lua
правильно обрабатывает эту ситуацию, используя концепцию замыкания
(```closure```).

Проще говоря, замыкание — это функция вместе со всем, что
ей нужно для правильного доступа к нелокальным переменным. Если мы
снова вызовем ```newCounter```, то она создаст новую локальную переменную
```i```, поэтому мы получим новое замыкание, действующее поверх новой
переменной:

```lua
c2 = newCounter()
print(c2()) --> 1
print(c1()) --> 3
print(c2()) --> 2
```

Таким образом, ```c1``` и ```с2``` — это разные замыкания поверх одной и той же
функции, и каждое замыкание воздействует на независимый экземпляр
локальной переменной ```i```.

С технической точки зрения, значением в Lua является замыкание, а
не функция. Сама по себе функция — это лишь прототип для замыканий.
Тем не менее, мы продолжим использовать термин «функция» для
обозначения замыкания везде, где это не приведет к путанице.

Во многих случаях замыкания оказываются ценным инструментом.
Как мы уже видели, они удобны в качестве аргументов функций высших
порядков, таких как sort. Замыкания также ценны для функций, которые
строят другие функции, как в нашем примере с newCounter или с
производной; этот механизм позволяет программам Lua внедрять
современные методы из мира функционального программирования.

Замыкания также удобны для функций обратного вызова (```callback```).
Здесь подходит типичный пример про создание кнопок в традиционном
инструментарии GUI. У каждой кнопки есть функция обратного вызова,
которая должна быть вызвана, когда пользователь нажимает эту кнопку;
вам требуется, чтобы разные кнопки совершали немного разные
действия при нажатии. Например, цифровому калькулятору нужно
десять похожих кнопок, по одной на каждую цифру. Вы можете создать
каждую кнопку с помощью функции наподобие этой:

```lua
function digitButton (digit)
  return Button{ label = tostring(digit),
  action = function ()
    add_to_display(digit)
  end
  }
end
```

В данном примере мы предполагаем, что ```Button``` — это функция из
инструментария, которая создает новые кнопки; ```label``` — это метка
кнопки; ```action``` — это замыкание обратного вызова, которое нужно
вызвать при нажатии кнопки. Обратный вызов может быть произведен
спустя длительное время после того, как ```digitButton``` выполнила свою
задачу, и после того, как локальная переменная ```digit``` вышла из области
видимости, так как он по-прежнему может обращаться к этой
переменной.

Замыкания также ценны в совсем другом случае. Поскольку функции
Lua хранятся в обычных переменных, мы можем их легко
переопределять, даже если они встроенные.

Часто, когда вы
переопределяете функцию, в новой реализации вам все равно нужна
изначальная функция. Например, предположим, что вы хотите
переопределить функцию ```sin```, чтобы она работала с градусами вместо
радиан. Эта новая функция конвертирует свой аргумент и затем
вызывает исходную функцию ```sin``` для выполнения настоящей работы.
Ваш код при этом может выглядеть следующим образом:

```lua
oldSin = math.sin
math.sin = function (x)
  return oldSin(x*math.pi/180)
end
```

Далее приведен немного более аккуратный способ выполнить это
переопределение:

```lua
do
  local oldSin = math.sin
  local k = math.pi/180
  math.sin = function (x)
    return oldSin(x*k)
  end
end
```
Теперь мы сохраняем старую версию в локальной переменной;
единственный способ обратиться к ней — через новую функцию.

## Неглобальные функции

Очевидным следствием того, что функции являются значениями
первого класса, является то, что мы можем хранить функции не только в
глобальных переменных, но и в локальных переменных и полях таблицы.

Мы уже видели некоторые примеры функций внутри полей таблиц:
большинство библиотек Lua использует этот механизм (например,
```io.read```, ```math.sin```). Для создания подобных функций в Lua нам нужно
просто соединить стандартный синтаксис для функций с синтаксисом
для таблиц:

```lua
Lib = {}
Lib.foo = function (x,y) return x + y end
Lib.goo = function (x,y) return x - y end
print(Lib.foo(2, 3), Lib.goo(2, 3)) --> 5 -1
```

Разумеется, мы также можем использовать конструкторы:

```lua
Lib = {
  foo = function (x,y) return x + y end,
  goo = function (x,y) return x - y end
}
```

Кроме того, Lua предлагает еще один синтаксис для определения
подобных функций:

``` lua
Lib = {}
function Lib.foo (x,y) return x + y end
function Lib.goo (x,y) return x - y end
```

Когда мы сохраняем функцию в локальной переменной, мы получаем
локальную функцию, то есть функцию с ограниченной областью
видимости. Подобные определения особенно удобны для пакетов:
поскольку Lua рассматривает каждый кусок как функцию, кусок может
объявлять локальные функции, которые видны только внутри него.

Лексическая область видимости позволяет другим функциям из пакета
использовать эти локальные функции:

```lua
local f = function (<параметры>)
  <тело>
end

local g = function (<параметры>)
  <какой-нибудь код>
  f() -- 'f' здесь видима
  <какой-нибудь код>
end
```

Lua поощряет подобное применение локальных функций посредством
синтаксическего сахара:

``` lua
local function f (<params>)
  <тело>
end
```

При определении рекурсивных локальных функций возникает
требующий уточнения момент. Дело в том, что обычный подход здесь
не работает. Рассмотрим следующее определение:

```lua
local fact = function (n)
  if n == 0 then return 1
  else return n*fact(n-1) -- глюк
  end
end
```

Когда Lua компилирует вызов ```fact(n—1)``` в теле функции, локальная
функция ```fact``` еще не определена. Поэтому данное выражение
попытается вызвать глобальную функцию ```fact```, а не локальную. Мы
можем решить эту проблему, сперва определив локальную переменную,
а затем уже саму функцию:

```lua
local fact
fact = function (n)
  if n == 0 then return 1
  else return n*fact(n-1)
  end
end
```

Теперь ```fact``` внутри функции ссылается на локальную переменную. Ее
значение при определении функции не важно; к моменту выполнения
функции, ```fact``` уже получит правильное значение.

Когда Lua предлагает свой синтаксический сахар для локальных
функций, он не использует простое определение. Вместо этого
определение наподобие
```lua
local function foo (<параметры>) <тело> end
```

расширяется до
```lua
local foo; foo = function (<параметры>) <тело> end
```

Поэтому мы можем спокойно использовать этот синтаксис для
рекурсивных функций.

Конечно, этот прием не сработает, если у вас косвенно рекурсивные
функции (поочередно вызывающие друг друга). В таких случаях вы
должны использовать эквивалент явного предварительного объявления:

```lua
local f, g -- предварительные объявления

function g ()
  <какой-нибудь код> f() <какой-нибудь код>
end

function f ()
  <какой-нибудь код> g() <какой-нибудь код>
end
```
Остерегайтесь писать ```local function f``` в последнем определении.
Иначе Lua создаст новую локальную переменную ```f```, оставив
изначальную ```f``` (к которой привязана ```g```) неопределенной.

# То, что нужно знать до ООП.

ООП в Lua, в принципе как и всё остальное, реализовано при помощи таблиц (и метатаблиц).
Начнём с определения таблицы:

```lua
tbl = {}
```

Как мы уже знаем, таблицы здесь играют роль списков (sequences), ассоциативных массивов, etc. 
Таблица - композитный тип данных, туда можно запихать всё, что душе угодно. 
Таблицу, по-умолчанию, стоит рассматривать, как ассоциатиыный массив. 

```lua
tbl = {}

tbl[1] = 12 --мы можем хранить в таблице что-то по числовому индексу
tbl[2] = "Hello, Vitaly!" 
tbl["13"] = 77 --а так же, по ключевому слову (пара ключ-значение)
```

Для каждой таблицы, мы можем создавать методы:

```lua
User = {}

function User:some_func()
  print("What a wonderful day!")
end
```

Но это пока лишь приблежает нас к ООП. 
Настоящее ООП начинается там, где появляются метатаблицы.
Метатаблица мало чем отличается от обычной таблицы: она указана как управляющая, вот и всё различие.
В метатаблице описывается реакция основной таблицы на воздействия, например, вызов таблицы как функции или попытка вытянуть из неё ключ, которого у неё нет, благодаря специальным ключам;

## Метаметоды, доступные в метатаблицах: 
1. ```__index``` — функция или таблица, с помощью которых оригинальная таблица ищет ключи, если их не существует;
2. ```__newindex``` — функция, как добавлять в таблицу *новые* ключи, на уже существующие — не действует;
3. ```__call``` — фунция, которая вызовется когда таблицу попробуют вызвать как как функцию;
4. ```__tostring``` — функция, вызывающаяся при попытке преобразовать таблицу в строку, например, при ```print``` или ```tostring```, сочетается с ```__concat```;
5. ```__concat``` — функция, вызывающаяся при попытке конкатенации таблицы с чем либо, сочетается с ```__tostring```;
6. ```__metatable``` — значение, которое возвращается попытке взять метатаблицу у данной таблицы, позволяет скрывать метатаблицы;
7. ```__mode``` — строка, управляющая «силой» связей в таблице при сборке мусора, с её помощью можно создавать таблицы слабых ссылок или эфемероны;
8. ```__gc``` — функция, которая будет вызвана при сборе userdata или таблицы мусорщиком, если очень хочется в 5.1 — есть способ применения;
9. ```__len``` — функция которая будет вызываться при попытке вычисления длины таблицы, с помощью оператора ```#``` (оператор получения длинны списка, если наша таблица представляет собой список);
10. ```__pairs``` — функция, альтернатива итератора ```pairs``` для данной таблицы;
11. ```__ipairs``` — функция, альтернатива ```ipairs```;



## Математические метаметоды и сравнение (функции)

1. ```__add``` — (+) сложение;
2. ```__sub``` — (-) вычитание;
3. ```__mul``` — (*) умножение;
4. ```__div``` — (/) деление;
5. ```__pow``` — (^) возведение в степень;
6. ```__mod``` — (%) деление по модулю;
7. ```__idiv``` — (//) деление с изъятием целой части (5.3+);
8. ```__eq``` — (==) сравнение равенства;
9. ```__lt``` — (<) сравнение «меньше чем», в обратную сторону выполняется автоматически, реверсируя аргументы;
10. ```__le``` — (<=) сравнение «меньше или равно»;

## Битовые операции (функции, только Lua 5.3+)
1. ```__band``` — (&) «И»;
2. ```__bor``` — (|) «ИЛИ»;
3. ```__bxor``` — (~) исключающее «ИЛИ» (a ~ b);
4. ```__bnot``` — (~) «НЕТ» (~a);
5. ```__shl``` — (<<) битовый сдвиг влево;
6. ```__shr``` — (>>) битовый сдвиг вправо.


# Примеры использования:

### Index
```lua 
--[[1]]
foo = {}
foo.key = 'value'

--[[2]]
mt = {__index = foo}

-- setmetatable возвращает первый переданный в неё аргумент
--[[3]] 
bar = setmetatable({}, mt)
bar.key2 = 'value2'


-- Тестирование:

--[[4]] 
print('bar.key2', bar.key2) --> 'value2'

--[[5]] 
print('bar.key', bar.key) --> 'value'
```
Что тут происходит:

1. ```foo``` — таблица, в которой мы будем искать ключи, которых у нас нет.
2. ```mt``` — таблица, с ключом ```__index = foo```. Если её прицепить к чему-то как метатаблицу, она будет указывать: «Если у нет ключей — попробуйте найти их в foo».
3. Тут — процесс цепляния метатаблицы ```mt``` к пустой таблице (которой становится ```bar```)
4. Пример прямого доступа к ключам таблицы. В данном случае, мы берём ключ как обычно, из таблицы ```bar```.
5. Пример доступа к ключам по ```__index```. В данном случае, в таблице bar отсутствует ключ ```["key"]```, и мы ищем его по ```__index``` метатаблицы — в таблице ```foo```.
 
 
 ### NewIndex
 
 Не настолько распространённый метаметод, но тоже иногда удобный для создания закрытых таблиц, фильтрации или проксирования, и ещё нескольких вещей.

Всегда может быть только функцией, с аргументами ```(self, key, value)```.

Иногда может быть вреден, поэтому для принудительного не-использования данного метаметода используется функция ```rawset(self, key, value)```, который является функцией для таблиц по умолчанию.

```lua
--[[1]]
foo = {}
mt  = {}
function mt.__newindex(self, key, value)
	foo[key] = value
end

bar = setmetatable({a = 10}, mt)
bar.key = 'value'

print('bar.key', bar.key) --> nil
print('foo.key', foo.key) --> 'value'
```

Это — простейший пример добавления ключей через прокс-таблицу с помощью метаметода ```__newindex```. Все новые ключи-значения, которые мы добавляем в таблицу ```bar```, добавляются в ```foo``` в соответствии с функцией. ```Self```, в данном случае — таблица ```bar```;

### Call
```lua
mt  = {}
function mt.__call(self, a, b, c, d)
	return a..b..c..d
end

foo = setmetatable({}, mt)
foo.key = 'value'

print(foo(10, 20, 30, '!')) --> 102030!
print(foo.key) --> 'value'
print(foo.bar) --> nil
```

Данный метаметод удобен для сокращения элементов или вызова дефолтных методов функций с таблицами и для чуть более комфортного ООП, когда мы вызываем таблицу-класс как функцию, и получаем объект.


### Tostring и Concat

Просто приведение объекта к строке и конкатенация.

```lua
mt = {}
function mt.__tostring(self)
	return '['..table.concat(self, ', ')..']'
end

foo = setmetatable({}, mt)
foo[1] = 10
foo[2] = 20
foo[3] = 30

print('foo', foo) --> [10, 20, 30]

-- print('foo..foo', foo..foo)
-- Ошибка! Невозможно конкатенировать таблицу!

function mt.__concat(a, b)
	return tostring(a)..tostring(b)
end

print('foo.."!"', foo.."!") --> [10, 20, 30]!
print('"!"..foo', "!"..foo) --> ![10, 20, 30]
print('foo..foo', foo..foo) --> [10, 20, 30][10, 20, 30]
```

### Len

Функция, переопределяющая алгоритм вычисления длины таблицы (Lua 5.2+).
```lua
mt = {}

function mt.__len(self)
	local keys = 0
	for k, v in pairs(self) do
		keys = keys + 1
	end
	return keys
end

foo = setmetatable({}, mt)

foo[1]  = 10
foo[2]  = 20
foo.key = 'value'

print('#foo', #foo) --> 3 (2 в Lua 5.1)
```

### Pairs и Ipairs

Переопределение стандартных итераторов таблиц, для данной таблицы (Lua 5.2+).

```lua
mt = {}

function mt.__pairs(self)
	local key, value = next(self)
	
	return function()
		key, value = next(self, key)
		
		-- Отфильтовываем не-числовые ключи.
		while key and type(key) == 'number' do
			key, value = next(self, key)
		end
		return key, value
	end
end

function mt.__ipairs(self)
	local i = 0
	
	-- ipairs по отрицательным числам.
	return function()
		i = i - 1
		return self[i] and i, self[i]
	end
end

foo = setmetatable({}, mt)
foo[1]  = 10
foo[2]  = 20
foo[-1] = -10
foo[-2] = -20
foo.foo = 'foobar'
foo.bar = 'barfoo'

-- Lua 5.1 пройдёт по всем ключам,
-- 5.2+ - только по строковым
for k, v in pairs(foo) do 
	print('pairs test', k, v) 
end

--> foo foobar
--> bar barfoo


-- Lua 5.1 пройдёт по всем положительным числовым ключам, 
-- 5.2+ - только по отрицательным числовым
for i, v in ipairs(foo) do 
	print('ipairs test', i, v) 
end

--> -1 -10
--> -2 -20
```

### Перегрузка операторов

Перегрузка всех операторов работает по одной схеме, детальные примеры для каждого — не нужны.

```lua

--[[1]]
vector_mt = {}

function vector_mt.__add(a, b)
	local v = {}
	v.x = a.x + b.x
	v.y = a.y + b.y
	return setmetatable(v, vector_mt)
end

function vector_mt.__div(a, b)
	local v = {}
	v.x = a.x / b.x
	v.y = a.y / b.y
	return setmetatable(v, vector_mt)
end
-- Для удобства
function vector_mt.__tostring(self)
	return '['..self.x..', '..self.y..']'
end

vec1 = setmetatable({}, vector_mt)
vec1.x = 1
vec1.y = 2

vec2 = setmetatable({}, vector_mt)
vec2.x = 3
vec2.y = 4


vec3 = vec1 + vec2

print('vec3', vec3) --> [4, 6]
print('vec2 / vec1', vec2 / vec1) --> [3, 2]

--[[2]]
mt = {}

function mt.__add(a, b)
	local insert_position = 1
	
	if type(a) == 'table' and getmetatable(a) == mt then
		insert_position = #a + 1
	else
		a, b = b, a
	end
		
	table.insert(a, insert_position, b)
	return a
end

-- Для удобства
function mt.__tostring(self)
	return '['..table.concat(self, ', ')..']'
end


foo = setmetatable({}, mt)

--[[3]]
foo = 3 + 4 + foo + 10 + 20 + 'a' + 'b'

print('foo', foo) --> [7, 10, 20, a, b]

foo = '12345' + foo
print('foo', foo) --> [12345, 7, 10, 20, a, b]
```

1. Пример перегрузки операторов на таблицах, которые ведут себя как векторы, благодаря метатаблице. Следует следить за порядком аргументов, каждая операция — возвращает новую таблицу-«вектор».

2. Таблица, в которую можно добавлять элементы оператором ```"+"```.
Порядок добавления определяет, в конец или в начало мы добавляем элемент.

3. ```3 + 4``` выполнится первым, поэтому первый элемент — ```«7»```.
В остальных случаях — к результату выполнения предыдущего элемента будет прибавляться следующий:
```((7 + foo -> foo) + 10 -> foo)…```



## Начала ООП

Первое что напрашивается — попытка сделать ООП.
Попробуем написать простую функцию, реализующую некоторый абстрактный «класс»:

```lua
function Class()
	local class = {}
	
	-- Метатаблица для класса.
	local mClass = {__index = class}
	
	-- Функция, которая возвращает "объект" данного класса.
	function class.instance()
		return setmetatable({}, mClass)
	end
	return class
end


-- Пока без двоеточий.
Rectangle = Class()

function Rectangle.new(x, y, w, h)
	local self = Rectangle.instance()
  self.x = x or 0
  self.y = y or 0
	self.w = w or 10
	self.h = h or 10
	return self
end


function Rectangle.area(self)
	return self.w * self.h
end

-- Инстанцируем
rect = Rectangle.new(10, 20, 30, 40)

print('rect.area(rect)', rect.area(rect)) --> 1200
print('rect:area()',     rect:area())     --> 1200
```

Вот, уже что-то похожее на ООП. Тут нет наследования и всяких крутых штук, но это уже неплохо.
При вызове rect.area, у таблицы-объекта нет ключа area, поэтому она идёт искать его через ```__index``` у таблицы-класса, находит, и подставляет туда саму себя первым аргументом.

Можно попробовать слегка улучшить данный вариант.
Во-первых, добавить возможность вызывать класс как функцию с возвратом объекта, во-вторых, добавить возможность перегрузки операторов у самого класса, В третьих — наследование.

```lua
function Class(parent)
  local class = {}
	local mClass = {}
	
	-- Сам класс будет метатаблицей для объектов.
	-- Это позволит дописывать ему метаметоды.
	class.__index = class

	-- Поля объектов будут искаться по цепочке __index, 
	-- и дотянутся, в том числе, до родительского класса.
	mClass.__index = parent 

	-- Резервируем поле Super под родителя.
	class.Super    = parent
	
	
	-- Функция, которая будет вызываться при вызове класса
	function mClass:__call(...)
		local instance = setmetatable({}, class)
		
		-- Резервируем поле класса "init"
		if type(class.init) == 'function' then
			-- Возвращаем экземпляр и всё что он вернул функцией init
			return instance, instance:init(...)
		end
		
		-- Но если её нет - тоже ничего.
		return instance
	end
	
	return setmetatable(class, mClass)
end

-- Основной класс.
Shape = Class()

function Shape:init(x, y)
	-- в качестве self мы сюда передаём инстанс объекта.
	self.x = x or 0
	self.y = y or 0
	
	return '!!!'
end

function Shape:posArea()
	return self.x * self.y
end

-- Так как таблица Shape является метатаблицей для рождаемых ей объектов,
-- мы можем дописывать ей метаметоды.
function Shape:__tostring()
	return '[' .. self.x .. ', ' .. self.y ..']'
end

local foo, value = Shape(10, 20)

print('foo, value', foo, value) --> [10, 20] !!!

-- Наследник
Rectangle = Class(Shape)

function Rectangle:init(x, y, w, h)
	-- В данный момент, self - это пустая таблица,
	-- к которой прицеплена таблица Rectangle, как мета.
	
	-- Вызов родительских методов через Super.
	self.Super.init(self, x, y)
	-- Вызов собственных методов при инициализации - тоже возможен.
	self.w, self.h = self:getDefault(w, h)
end

function Rectangle:area()
	return self.w * self.h
end

function Rectangle:getDefault(w, h)
	return w or 10, h or 20
end

function Rectangle:__tostring()
	return '['..self.x..', '..self.y..', '..self.w .. ', '..self.h..']'
end

rect = Rectangle(10, 20, 30, 40)

print('rect',           rect)           --> [10, 20, 30, 40]

print('rect:area()'   , rect:area())    --> 30 * 40 = 1200

-- Вызов родительского метода
print('rect:posArea()', rect:posArea()) --> 10 * 20 = 200
```

Таким образом, в 15 строк полезного кода, можно имплементировать в Lua максимум из действительно необходимого ООП.
